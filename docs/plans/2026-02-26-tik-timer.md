# Tik Timer Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build `tik`, a polished macOS command-line countdown timer with presets, session logging, and a minimal centered terminal UI.

**Architecture:** Single-binary Rust CLI. Two modes: timer (default) and log (subcommand). Timer runs an async countdown loop on tokio with crossterm for rendering and keyboard input. Config via TOML, logs via newline-delimited JSON.

**Tech Stack:** Rust, clap (derive), tokio, crossterm, notify-rust, serde/serde_json/toml, chrono, dirs, regex

---

### Task 1: Project Scaffolding

**Files:**
- Create: `Cargo.toml`
- Create: `src/main.rs`
- Create: `src/duration.rs`
- Create: `src/config.rs`
- Create: `src/timer.rs`
- Create: `src/render.rs`
- Create: `src/notify.rs`
- Create: `src/log.rs`

**Step 1: Initialize Cargo project and git**

```bash
cd /Users/jakubawieruk/Development/experimental/pomodoro_rust
cargo init --name tik
git init
```

**Step 2: Add dependencies to Cargo.toml**

```toml
[dependencies]
clap = { version = "4", features = ["derive"] }
tokio = { version = "1", features = ["rt-multi-thread", "macros", "time", "sync"] }
crossterm = "0.28"
notify-rust = "4"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
toml = "0.8"
chrono = { version = "0.4", features = ["serde"] }
dirs = "6"
regex = "1"
```

**Step 3: Create module stubs**

Create each module file with a placeholder comment. `src/main.rs` should declare all modules:

```rust
mod config;
mod duration;
mod log;
mod notify;
mod render;
mod timer;

fn main() {
    println!("tik");
}
```

Each module file (`duration.rs`, `config.rs`, `timer.rs`, `render.rs`, `notify.rs`, `log.rs`) is empty initially.

**Step 4: Verify it compiles**

Run: `cargo build`
Expected: Compiles with warnings about unused modules.

**Step 5: Add .gitignore and commit**

```bash
echo "/target" > .gitignore
git add Cargo.toml Cargo.lock src/ .gitignore
git commit -m "chore: scaffold tik project with dependencies and module stubs"
```

---

### Task 2: Duration Parsing

**Files:**
- Modify: `src/duration.rs`

**Step 1: Write tests for duration parsing**

Add to `src/duration.rs`:

```rust
use regex::Regex;
use std::fmt;

#[derive(Debug, Clone, PartialEq)]
pub struct Duration {
    pub total_secs: u64,
}

impl Duration {
    pub fn parse(input: &str) -> Result<Self, String> {
        todo!()
    }

    pub fn format_hms(&self) -> String {
        todo!()
    }
}

impl fmt::Display for Duration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.format_hms())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_minutes_only() {
        assert_eq!(Duration::parse("25m").unwrap().total_secs, 1500);
    }

    #[test]
    fn parse_seconds_only() {
        assert_eq!(Duration::parse("90s").unwrap().total_secs, 90);
    }

    #[test]
    fn parse_hours_only() {
        assert_eq!(Duration::parse("1h").unwrap().total_secs, 3600);
    }

    #[test]
    fn parse_hours_and_minutes() {
        assert_eq!(Duration::parse("1h30m").unwrap().total_secs, 5400);
    }

    #[test]
    fn parse_all_components() {
        assert_eq!(Duration::parse("1h30m15s").unwrap().total_secs, 5415);
    }

    #[test]
    fn parse_invalid_returns_error() {
        assert!(Duration::parse("abc").is_err());
    }

    #[test]
    fn parse_zero_returns_error() {
        assert!(Duration::parse("0m").is_err());
    }

    #[test]
    fn format_minutes_and_seconds() {
        let d = Duration { total_secs: 1500 };
        assert_eq!(d.format_hms(), "25:00");
    }

    #[test]
    fn format_with_hours() {
        let d = Duration { total_secs: 5415 };
        assert_eq!(d.format_hms(), "1:30:15");
    }

    #[test]
    fn format_seconds_only() {
        let d = Duration { total_secs: 45 };
        assert_eq!(d.format_hms(), "0:45");
    }

    #[test]
    fn format_human_readable() {
        let d = Duration { total_secs: 1500 };
        assert_eq!(d.to_string(), "25:00");
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test duration`
Expected: All tests fail with "not yet implemented".

**Step 3: Implement duration parsing**

Replace the `todo!()` in `parse`:

```rust
pub fn parse(input: &str) -> Result<Self, String> {
    let re = Regex::new(r"^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$").unwrap();
    let caps = re.captures(input).ok_or_else(|| format!("Invalid duration: '{input}'"))?;

    let hours: u64 = caps.get(1).map_or(0, |m| m.as_str().parse().unwrap());
    let minutes: u64 = caps.get(2).map_or(0, |m| m.as_str().parse().unwrap());
    let seconds: u64 = caps.get(3).map_or(0, |m| m.as_str().parse().unwrap());

    let total_secs = hours * 3600 + minutes * 60 + seconds;
    if total_secs == 0 {
        return Err("Duration must be greater than zero".to_string());
    }

    Ok(Duration { total_secs })
}
```

Replace the `todo!()` in `format_hms`:

```rust
pub fn format_hms(&self) -> String {
    let h = self.total_secs / 3600;
    let m = (self.total_secs % 3600) / 60;
    let s = self.total_secs % 60;

    if h > 0 {
        format!("{h}:{m:02}:{s:02}")
    } else {
        format!("{m}:{s:02}")
    }
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test duration`
Expected: All 11 tests PASS.

**Step 5: Commit**

```bash
git add src/duration.rs
git commit -m "feat: add duration parsing with h/m/s support and formatting"
```

---

### Task 3: Config Module

**Files:**
- Modify: `src/config.rs`

**Step 1: Write tests for config loading**

```rust
use serde::Deserialize;
use std::collections::HashMap;
use std::path::PathBuf;

#[derive(Debug, Deserialize, Default)]
pub struct Config {
    #[serde(default)]
    pub presets: HashMap<String, String>,
}

impl Config {
    pub fn load() -> Self {
        todo!()
    }

    pub fn config_path() -> PathBuf {
        todo!()
    }

    fn defaults() -> HashMap<String, String> {
        HashMap::from([
            ("pomodoro".to_string(), "25m".to_string()),
            ("break".to_string(), "5m".to_string()),
            ("long-break".to_string(), "15m".to_string()),
        ])
    }

    pub fn resolve_preset(&self, name: &str) -> Option<&str> {
        self.presets.get(name).map(|s| s.as_str())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn defaults_include_pomodoro() {
        let defaults = Config::defaults();
        assert_eq!(defaults.get("pomodoro").unwrap(), "25m");
    }

    #[test]
    fn defaults_include_break() {
        let defaults = Config::defaults();
        assert_eq!(defaults.get("break").unwrap(), "5m");
    }

    #[test]
    fn defaults_include_long_break() {
        let defaults = Config::defaults();
        assert_eq!(defaults.get("long-break").unwrap(), "15m");
    }

    #[test]
    fn parse_toml_config() {
        let toml_str = r#"
[presets]
focus = "50m"
rest = "10m"
"#;
        let config: Config = toml::from_str(toml_str).unwrap();
        assert_eq!(config.presets.get("focus").unwrap(), "50m");
        assert_eq!(config.presets.get("rest").unwrap(), "10m");
    }

    #[test]
    fn resolve_preset_found() {
        let mut config = Config::default();
        config.presets.insert("pomodoro".to_string(), "25m".to_string());
        assert_eq!(config.resolve_preset("pomodoro"), Some("25m"));
    }

    #[test]
    fn resolve_preset_not_found() {
        let config = Config::default();
        assert_eq!(config.resolve_preset("nonexistent"), None);
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test config`
Expected: Tests that call `load()` or `config_path()` fail.

**Step 3: Implement config loading**

```rust
pub fn config_path() -> PathBuf {
    dirs::config_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("tik")
        .join("config.toml")
}

pub fn load() -> Self {
    let mut presets = Self::defaults();

    let path = Self::config_path();
    if path.exists() {
        if let Ok(contents) = std::fs::read_to_string(&path) {
            if let Ok(user_config) = toml::from_str::<Config>(&contents) {
                // User presets override defaults
                for (k, v) in user_config.presets {
                    presets.insert(k, v);
                }
            }
        }
    }

    Config { presets }
}
```

**Step 4: Run tests to verify they pass**

Run: `cargo test config`
Expected: All 6 tests PASS.

**Step 5: Commit**

```bash
git add src/config.rs
git commit -m "feat: add config module with TOML loading and built-in presets"
```

---

### Task 4: Session Log — Data & Append

**Files:**
- Modify: `src/log.rs`

**Step 1: Write tests for log entry serialization and the log path**

```rust
use chrono::{DateTime, Local};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct LogEntry {
    pub name: String,
    pub duration_secs: u64,
    pub completed_at: DateTime<Local>,
}

pub fn log_path() -> PathBuf {
    dirs::data_local_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join("tik")
        .join("log.json")
}

pub fn append_entry(entry: &LogEntry) -> std::io::Result<()> {
    todo!()
}

pub fn read_entries() -> Vec<LogEntry> {
    todo!()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;

    #[test]
    fn serialize_log_entry() {
        let entry = LogEntry {
            name: "pomodoro".to_string(),
            duration_secs: 1500,
            completed_at: Local::now(),
        };
        let json = serde_json::to_string(&entry).unwrap();
        assert!(json.contains("pomodoro"));
        assert!(json.contains("1500"));
    }

    #[test]
    fn deserialize_log_entry() {
        let json = r#"{"name":"pomodoro","duration_secs":1500,"completed_at":"2026-02-26T15:30:00+01:00"}"#;
        let entry: LogEntry = serde_json::from_str(json).unwrap();
        assert_eq!(entry.name, "pomodoro");
        assert_eq!(entry.duration_secs, 1500);
    }

    #[test]
    fn roundtrip_entry() {
        let entry = LogEntry {
            name: "break".to_string(),
            duration_secs: 300,
            completed_at: Local::now(),
        };
        let json = serde_json::to_string(&entry).unwrap();
        let parsed: LogEntry = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.name, entry.name);
        assert_eq!(parsed.duration_secs, entry.duration_secs);
    }

    #[test]
    fn log_path_ends_with_expected() {
        let path = log_path();
        assert!(path.ends_with("tik/log.json"));
    }
}
```

Note: add `tempfile` as a dev dependency: `cargo add tempfile --dev`

**Step 2: Run tests to verify passing tests pass, and todo tests fail**

Run: `cargo test log`
Expected: serialize, deserialize, roundtrip, and log_path tests PASS. Any test calling `append_entry` or `read_entries` would fail.

**Step 3: Implement append and read**

```rust
pub fn append_entry(entry: &LogEntry) -> std::io::Result<()> {
    let path = log_path();
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent)?;
    }
    let mut file = std::fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(&path)?;
    let mut json = serde_json::to_string(entry)?;
    json.push('\n');
    std::io::Write::write_all(&mut file, json.as_bytes())?;
    Ok(())
}

pub fn read_entries() -> Vec<LogEntry> {
    let path = log_path();
    if !path.exists() {
        return Vec::new();
    }
    let contents = match std::fs::read_to_string(&path) {
        Ok(c) => c,
        Err(_) => return Vec::new(),
    };
    contents
        .lines()
        .filter(|l| !l.trim().is_empty())
        .filter_map(|l| serde_json::from_str(l).ok())
        .collect()
}
```

**Step 4: Run tests**

Run: `cargo test log`
Expected: All tests PASS.

**Step 5: Commit**

```bash
git add src/log.rs Cargo.toml Cargo.lock
git commit -m "feat: add session log with JSON append and read"
```

---

### Task 5: Log Summary Display

**Files:**
- Modify: `src/log.rs`

**Step 1: Write tests for summary formatting**

Add to `src/log.rs`:

```rust
use chrono::{Datelike, NaiveDate, Weekday};

pub fn print_summary() {
    todo!()
}

fn format_duration_human(secs: u64) -> String {
    todo!()
}

#[cfg(test)]
mod tests {
    // ... existing tests ...

    #[test]
    fn format_duration_human_minutes() {
        assert_eq!(format_duration_human(1500), "25m");
    }

    #[test]
    fn format_duration_human_hours_and_minutes() {
        assert_eq!(format_duration_human(5400), "1h 30m");
    }

    #[test]
    fn format_duration_human_hours_only() {
        assert_eq!(format_duration_human(3600), "1h 0m");
    }

    #[test]
    fn format_duration_human_zero() {
        assert_eq!(format_duration_human(0), "0m");
    }
}
```

**Step 2: Run tests to verify they fail**

Run: `cargo test log`
Expected: New tests fail with "not yet implemented".

**Step 3: Implement summary display**

```rust
fn format_duration_human(secs: u64) -> String {
    let h = secs / 3600;
    let m = (secs % 3600) / 60;
    if h > 0 {
        format!("{h}h {m}m")
    } else {
        format!("{m}m")
    }
}

pub fn print_summary() {
    let entries = read_entries();
    if entries.is_empty() {
        println!("No sessions logged yet.");
        return;
    }

    let now = Local::now();
    let today = now.date_naive();

    // Find start of this week (Monday)
    let days_since_monday = now.weekday().num_days_from_monday();
    let week_start = today - chrono::Duration::days(days_since_monday as i64);

    let today_entries: Vec<&LogEntry> = entries
        .iter()
        .filter(|e| e.completed_at.date_naive() == today)
        .collect();

    let week_entries: Vec<&LogEntry> = entries
        .iter()
        .filter(|e| e.completed_at.date_naive() >= week_start)
        .collect();

    // Print today
    print_section("Today", &today_entries);
    println!();
    print_section("This week", &week_entries);
}

fn print_section(title: &str, entries: &[&LogEntry]) {
    let total_secs: u64 = entries.iter().map(|e| e.duration_secs).sum();
    let count = entries.len();

    println!(
        "{title} ({count} session{}, {}):",
        if count == 1 { "" } else { "s" },
        format_duration_human(total_secs)
    );

    if entries.is_empty() {
        println!("  (none)");
        return;
    }

    // Group by name
    let mut by_name: HashMap<&str, (usize, u64)> = HashMap::new();
    for e in entries {
        let entry = by_name.entry(e.name.as_str()).or_insert((0, 0));
        entry.0 += 1;
        entry.1 += e.duration_secs;
    }

    let mut names: Vec<_> = by_name.into_iter().collect();
    names.sort_by(|a, b| b.1 .1.cmp(&a.1 .1));

    for (name, (count, secs)) in names {
        if count > 1 {
            println!("  {name:<14} x{count:<4} {}", format_duration_human(secs));
        } else {
            println!("  {name:<14}       {}", format_duration_human(secs));
        }
    }
}
```

Note: add `use std::collections::HashMap;` at the top of the file.

**Step 4: Run tests**

Run: `cargo test log`
Expected: All tests PASS.

**Step 5: Commit**

```bash
git add src/log.rs
git commit -m "feat: add log summary with today and this week grouping"
```

---

### Task 6: Notification Module

**Files:**
- Modify: `src/notify.rs`

**Step 1: Implement notification**

This is a thin wrapper — no unit tests needed; it calls OS APIs.

```rust
pub fn send_completion(name: &str, duration_display: &str, silent: bool) {
    let mut notification = notify_rust::Notification::new();
    notification
        .summary(&format!("{name} complete"))
        .body(&format!("{duration_display} timer finished"))
        .appname("tik");

    if !silent {
        notification.sound_name("Glass");
    }

    if let Err(e) = notification.show() {
        eprintln!("Failed to send notification: {e}");
    }
}
```

**Step 2: Verify it compiles**

Run: `cargo build`
Expected: Compiles (with some warnings about unused items).

**Step 3: Commit**

```bash
git add src/notify.rs
git commit -m "feat: add macOS notification on timer completion"
```

---

### Task 7: Render Module

**Files:**
- Modify: `src/render.rs`

**Step 1: Implement the terminal renderer**

```rust
use crossterm::{
    cursor,
    execute,
    style::{self, Attribute, Color, SetAttribute, SetForegroundColor, ResetColor, Print},
    terminal::{self, ClearType},
};
use std::io::{self, Write};

pub struct Renderer {
    bar_width: u16,
}

impl Renderer {
    pub fn new() -> Self {
        Renderer { bar_width: 30 }
    }

    pub fn setup(&self) -> io::Result<()> {
        terminal::enable_raw_mode()?;
        execute!(
            io::stdout(),
            terminal::EnterAlternateScreen,
            cursor::Hide,
        )?;
        Ok(())
    }

    pub fn teardown(&self) -> io::Result<()> {
        execute!(
            io::stdout(),
            cursor::Show,
            terminal::LeaveAlternateScreen,
        )?;
        terminal::disable_raw_mode()?;
        Ok(())
    }

    pub fn draw(&self, remaining_secs: u64, total_secs: u64, elapsed_secs: u64, paused: bool) -> io::Result<()> {
        let (cols, rows) = terminal::size()?;
        let mid_row = rows / 2;

        let remaining_str = format_time(remaining_secs);
        let elapsed_str = format_time(elapsed_secs);
        let progress = if total_secs > 0 {
            1.0 - (remaining_secs as f64 / total_secs as f64)
        } else {
            1.0
        };

        let filled = (progress * self.bar_width as f64) as u16;
        let empty = self.bar_width - filled;

        // Determine color based on remaining time
        let bar_color = if remaining_secs <= 60 {
            Color::Red
        } else if remaining_secs as f64 <= total_secs as f64 * 0.2 {
            Color::Yellow
        } else {
            Color::Green
        };

        let mut stdout = io::stdout();

        // Clear screen
        execute!(stdout, terminal::Clear(ClearType::All))?;

        // Remaining time (big, bold, centered)
        let time_col = cols.saturating_sub(remaining_str.len() as u16) / 2;
        execute!(
            stdout,
            cursor::MoveTo(time_col, mid_row - 1),
            SetAttribute(Attribute::Bold),
            Print(&remaining_str),
            SetAttribute(Attribute::Reset),
        )?;

        // Progress bar (centered)
        let bar_total_width = self.bar_width + 2; // +2 for brackets? No brackets, just blocks.
        let bar_col = cols.saturating_sub(bar_total_width) / 2;
        execute!(stdout, cursor::MoveTo(bar_col, mid_row + 1))?;

        execute!(stdout, SetForegroundColor(bar_color))?;
        for _ in 0..filled {
            execute!(stdout, Print("█"))?;
        }
        execute!(stdout, SetForegroundColor(Color::DarkGrey))?;
        for _ in 0..empty {
            execute!(stdout, Print("░"))?;
        }
        execute!(stdout, ResetColor)?;

        // Elapsed or paused label (dim, centered)
        let label = if paused {
            "PAUSED".to_string()
        } else {
            format!("{elapsed_str} elapsed")
        };
        let label_col = cols.saturating_sub(label.len() as u16) / 2;
        execute!(
            stdout,
            cursor::MoveTo(label_col, mid_row + 3),
            SetForegroundColor(Color::DarkGrey),
            Print(&label),
            ResetColor,
        )?;

        stdout.flush()?;
        Ok(())
    }
}

fn format_time(secs: u64) -> String {
    let h = secs / 3600;
    let m = (secs % 3600) / 60;
    let s = secs % 60;
    if h > 0 {
        format!("{h}:{m:02}:{s:02}")
    } else {
        format!("{m:02}:{s:02}")
    }
}
```

**Step 2: Verify it compiles**

Run: `cargo build`
Expected: Compiles successfully.

**Step 3: Commit**

```bash
git add src/render.rs
git commit -m "feat: add terminal renderer with colored progress bar"
```

---

### Task 8: Timer Core

**Files:**
- Modify: `src/timer.rs`

**Step 1: Implement the async timer loop**

```rust
use crossterm::event::{self, Event, KeyCode, KeyEvent, KeyModifiers};
use std::sync::Arc;
use std::time::Instant;
use tokio::sync::watch;

use crate::render::Renderer;

pub struct TimerResult {
    pub completed: bool,
}

pub async fn run(total_secs: u64, name: &str) -> TimerResult {
    let renderer = Renderer::new();
    if let Err(e) = renderer.setup() {
        eprintln!("Failed to setup terminal: {e}");
        return TimerResult { completed: false };
    }

    let (pause_tx, pause_rx) = watch::channel(false);
    let (quit_tx, mut quit_rx) = watch::channel(false);

    // Spawn input handler
    let pause_tx_clone = pause_tx.clone();
    let quit_tx_clone = quit_tx.clone();
    std::thread::spawn(move || {
        loop {
            if event::poll(std::time::Duration::from_millis(50)).unwrap_or(false) {
                if let Ok(Event::Key(key)) = event::read() {
                    match key {
                        KeyEvent {
                            code: KeyCode::Char(' '),
                            ..
                        } => {
                            let current = *pause_tx_clone.borrow();
                            let _ = pause_tx_clone.send(!current);
                        }
                        KeyEvent {
                            code: KeyCode::Char('q'),
                            ..
                        }
                        | KeyEvent {
                            code: KeyCode::Char('c'),
                            modifiers: KeyModifiers::CONTROL,
                            ..
                        } => {
                            let _ = quit_tx_clone.send(true);
                            break;
                        }
                        _ => {}
                    }
                }
            }
            if *quit_tx_clone.borrow() {
                break;
            }
        }
    });

    let start = Instant::now();
    let mut paused_duration = std::time::Duration::ZERO;
    let mut pause_start: Option<Instant> = None;
    let mut completed = false;

    loop {
        // Check quit
        if *quit_rx.borrow() {
            break;
        }

        let is_paused = *pause_rx.borrow();

        // Track pause duration
        if is_paused {
            if pause_start.is_none() {
                pause_start = Some(Instant::now());
            }
        } else if let Some(ps) = pause_start.take() {
            paused_duration += ps.elapsed();
        }

        let active_elapsed = start.elapsed() - paused_duration
            - pause_start.map_or(std::time::Duration::ZERO, |ps| ps.elapsed());

        let elapsed_secs = active_elapsed.as_secs();
        let remaining_secs = total_secs.saturating_sub(elapsed_secs);

        if let Err(_) = renderer.draw(remaining_secs, total_secs, elapsed_secs, is_paused) {
            break;
        }

        if remaining_secs == 0 {
            completed = true;
            // Hold the final display briefly
            tokio::time::sleep(std::time::Duration::from_secs(1)).await;
            break;
        }

        tokio::time::sleep(std::time::Duration::from_millis(250)).await;
    }

    let _ = renderer.teardown();
    TimerResult { completed }
}
```

**Step 2: Verify it compiles**

Run: `cargo build`
Expected: Compiles successfully.

**Step 3: Commit**

```bash
git add src/timer.rs
git commit -m "feat: add async timer loop with pause/resume and quit handling"
```

---

### Task 9: CLI Definition & Main Wiring

**Files:**
- Modify: `src/main.rs`

**Step 1: Implement the full CLI with clap**

```rust
mod config;
mod duration;
mod log;
mod notify;
mod render;
mod timer;

use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "tik", about = "A command-line countdown timer", version)]
struct Cli {
    /// Duration (e.g., 25m, 1h30m, 90s) or preset name (e.g., pomodoro, break)
    duration: Option<String>,

    /// Suppress notification sound
    #[arg(long)]
    silent: bool,

    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// Show session log summary
    Log,
}

#[tokio::main]
async fn main() {
    let cli = Cli::parse();

    // Handle subcommands
    if let Some(Commands::Log) = cli.command {
        log::print_summary();
        return;
    }

    // Must have a duration/preset argument
    let input = match cli.duration {
        Some(d) => d,
        None => {
            eprintln!("Usage: tik <duration|preset> or tik log");
            eprintln!("Examples: tik 25m, tik pomodoro, tik 1h30m");
            std::process::exit(1);
        }
    };

    // Try parsing as duration first, then as preset
    let config = config::Config::load();
    let (name, dur) = match duration::Duration::parse(&input) {
        Ok(d) => (input.clone(), d),
        Err(_) => {
            // Try as preset
            match config.resolve_preset(&input) {
                Some(preset_duration) => {
                    match duration::Duration::parse(preset_duration) {
                        Ok(d) => (input.clone(), d),
                        Err(e) => {
                            eprintln!("Invalid preset duration for '{input}': {e}");
                            std::process::exit(1);
                        }
                    }
                }
                None => {
                    eprintln!("Unknown duration or preset: '{input}'");
                    eprintln!("Valid formats: 25m, 1h30m, 90s");
                    eprintln!("Built-in presets: pomodoro, break, long-break");
                    std::process::exit(1);
                }
            }
        }
    };

    let display = dur.format_hms();
    let result = timer::run(dur.total_secs, &name).await;

    if result.completed {
        notify::send_completion(&name, &display, cli.silent);

        let entry = log::LogEntry {
            name,
            duration_secs: dur.total_secs,
            completed_at: chrono::Local::now(),
        };
        if let Err(e) = log::append_entry(&entry) {
            eprintln!("Failed to write log: {e}");
        }

        println!("Timer complete: {display}");
    } else {
        println!("Timer cancelled.");
    }
}
```

**Step 2: Verify it compiles and runs**

Run: `cargo build`
Expected: Compiles successfully.

Run: `cargo run -- --help`
Expected: Shows help text with usage info.

**Step 3: Commit**

```bash
git add src/main.rs
git commit -m "feat: wire up CLI with clap, config resolution, and main timer flow"
```

---

### Task 10: Manual Testing & Polish

**Step 1: Test with a short timer**

Run: `cargo run -- 5s`
Expected: Shows countdown from 5 seconds, progress bar fills, notification fires on completion.

**Step 2: Test pause/resume**

Run: `cargo run -- 10s`
Press space during countdown.
Expected: Timer pauses, shows "PAUSED", press space again to resume.

**Step 3: Test presets**

Run: `cargo run -- pomodoro`
Expected: Starts 25:00 countdown. (Ctrl+C to quit early.)

**Step 4: Test log**

Run: `cargo run -- log`
Expected: Shows summary of completed sessions.

**Step 5: Test silent flag**

Run: `cargo run -- --silent 5s`
Expected: Timer runs, notification appears but with no sound.

**Step 6: Fix any issues found during testing**

**Step 7: Final commit**

```bash
git add -A
git commit -m "chore: polish and verify all features working"
```

---

### Task 11: Cargo Install Verification

**Step 1: Install locally**

Run: `cargo install --path .`
Expected: Binary installed to `~/.cargo/bin/tik`.

**Step 2: Run from PATH**

Run: `tik 3s`
Expected: Works identically to `cargo run -- 3s`.

**Step 3: Commit any final Cargo.toml tweaks**

If any metadata changes needed for clean install.
